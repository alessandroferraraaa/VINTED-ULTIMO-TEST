name: Vinted Bot Monitor

on:
  schedule:
    # Esegui il bot ogni 30 minuti
    - cron: '*/30 * * * *'
  
  # Consenti esecuzione manuale da GitHub
  workflow_dispatch:

jobs:
  vinted-monitor:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Run Vinted Bot
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          python -c "
import requests
import json
import time
import logging
import re
from datetime import datetime
from typing import Dict, List, Optional
import sqlite3
from pathlib import Path
import os

# Load config from environment
CONFIG = {
    'DISCORD_WEBHOOK_URL': os.getenv('DISCORD_WEBHOOK_URL', ''),
    'TELEGRAM_BOT_TOKEN': os.getenv('TELEGRAM_BOT_TOKEN', ''),
    'TELEGRAM_CHAT_ID': os.getenv('TELEGRAM_CHAT_ID', ''),
    'VINTED_URLS': [
        'https://www.vinted.it/api/v2/catalog/items',
        'https://www.vinted.de/api/v2/catalog/items',
        'https://www.vinted.fr/api/v2/catalog/items',
        'https://www.vinted.es/api/v2/catalog/items',
        'https://www.vinted.nl/api/v2/catalog/items',
        'https://www.vinted.be/api/v2/catalog/items',
    ],
    'CHECK_INTERVAL': 60,
    'DB_NAME': 'vinted_bot.db',
    'LOG_LEVEL': logging.INFO,
}

logging.basicConfig(
    level=CONFIG['LOG_LEVEL'],
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('vinted_bot.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Data validation
APPROVED_TEAMS = {
    'liverpool', 'manchester city', 'olympique marsiglia', 'lione', 'psg',
    'borussia dortmund', 'bayern monaco', 'inter', 'manchester united',
    'argentina', 'francia', 'spagna', 'arsenal', 'tottenham',
    'real madrid', 'barcellona', 'atletico madrid', 'chelsea',
    'napoli', 'roma', 'juventus', 'ac milan'
}

APPROVED_BRANDS = {
    'nike', 'adidas', 'puma', 'lotto', 'reebok', 'umbro', 'kappa'
}

ALLOWED_SIZES = {'XS', 'S', 'M', 'L', 'XL'}

FORBIDDEN_KEYWORDS = {
    'solo pantalone', 'solo felpa', 'joggers', 'bottom', 'piece 1',
    'short', 'shorts', 'maillot', 'kids', 'junior', 'academy',
    'enfant', 'gar√ßon', 'bambino', 'child', 'children', 'youth',
    'training set', 'kit gara', 'summer', 'estivo', 'tees',
    'polo', 'shirt', 'maglietta', 'canotta', 'singlet'
}

FORBIDDEN_AGE_KEYWORDS = {
    'anni', 'years', 'age', 'mesi', 'months', 'cm', 'taglia bimbo',
    'kids size', 'child size', 'ragazzo', 'ragazza', '16 anni'
}

APPROVED_COMBINATIONS = {
    'tuta calcio', 'tuta da calcio', 'tracksuit', 'football tracksuit',
    'surv√™tement', 'ensemble', 'completo', 'set completo'
}

ACCEPTABLE_CONDITIONS = {
    'Ottime condizioni',
    'Nuovo senza cartellino',
    'Nuovo con cartellino'
}

# Database
def init_database():
    conn = sqlite3.connect(CONFIG['DB_NAME'])
    cursor = conn.cursor()
    cursor.execute(\"\"\"
        CREATE TABLE IF NOT EXISTS items (
            item_id INTEGER PRIMARY KEY,
            title TEXT NOT NULL,
            price REAL,
            team TEXT,
            brand TEXT,
            size TEXT,
            condition TEXT,
            image_url TEXT,
            vinted_url TEXT,
            status TEXT,
            reason_rejected TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            published_at DATETIME
        )
    \"\"\")
    cursor.execute(\"\"\"
        CREATE TABLE IF NOT EXISTS notified (
            item_id INTEGER PRIMARY KEY,
            notification_type TEXT,
            sent_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    \"\"\")
    conn.commit()
    conn.close()
    logger.info('‚úÖ Database initialized')

def check_size(size: str) -> bool:
    if not size:
        return False
    normalized = size.strip().upper()
    if any(keyword in normalized.lower() for keyword in FORBIDDEN_AGE_KEYWORDS):
        return False
    return normalized in ALLOWED_SIZES

def check_forbidden_keywords(text: str) -> bool:
    if not text:
        return False
    text_lower = text.lower()
    for keyword in FORBIDDEN_KEYWORDS:
        if keyword in text_lower:
            return True
    for keyword in FORBIDDEN_AGE_KEYWORDS:
        if keyword in text_lower:
            return True
    return False

def check_team(title: str, description: str = '') -> Optional[str]:
    text = (title + ' ' + description).lower()
    for team in APPROVED_TEAMS:
        if team in text:
            return team
    return None

def check_brand(title: str, description: str = '') -> Optional[str]:
    text = (title + ' ' + description).lower()
    for brand in APPROVED_BRANDS:
        if brand in text:
            return brand
    return None

def is_complete_tracksuit(item: Dict) -> tuple[bool, str]:
    title = item.get('title', '').lower()
    description = item.get('description', '').lower()
    
    if check_forbidden_keywords(title) or check_forbidden_keywords(description):
        return False, 'Contains forbidden keywords'
    
    has_approved_combo = any(combo in title or combo in description 
                            for combo in APPROVED_COMBINATIONS)
    
    if not has_approved_combo:
        has_jacket = any(word in title for word in ['felpa', 'giacca', 'jacket', 'hoodie'])
        has_pants = any(word in title for word in ['pantalone', 'pants', 'trousers'])
        
        if not (has_jacket and has_pants):
            return False, 'Not a complete tracksuit (missing jacket or pants)'
    
    size = item.get('size_title', '').strip()
    if not check_size(size):
        return False, f\"Size '{size}' not allowed (only S/M/L/XL for adults)\"
    
    team = check_team(title, description)
    if not team:
        return False, 'Team not in approved list'
    
    condition = item.get('status', '')
    if condition not in ACCEPTABLE_CONDITIONS:
        return False, f\"Condition '{condition}' not acceptable\"
    
    return True, 'Valid tracksuit'

def validate_item(item: Dict) -> tuple[bool, Optional[str], Optional[str]]:
    is_valid, reason = is_complete_tracksuit(item)
    
    if not is_valid:
        logger.info(f\"‚ùå Item rejected: {item.get('id')} - {reason}\")
        return False, None, reason
    
    team = check_team(item.get('title', ''), item.get('description', ''))
    logger.info(f\"‚úÖ Item approved: {item.get('id')} - Team: {team}\")
    
    return True, team, None

def create_session() -> requests.Session:
    session = requests.Session()
    session.headers.update({
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Accept': 'application/json',
        'Accept-Language': 'it-IT,it;q=0.9',
        'Cache-Control': 'no-cache'
    })
    return session

def fetch_vinted_items(session: requests.Session, url: str, search_params: Dict) -> Optional[List[Dict]]:
    try:
        response = session.get(url, params=search_params, timeout=10)
        if response.status_code == 429:
            logger.warning('‚ö†Ô∏è Rate limit hit! Waiting 60 seconds...')
            time.sleep(60)
            return None
        if response.status_code != 200:
            logger.error(f'API Error {response.status_code}: {response.text}')
            return None
        data = response.json()
        return data.get('items', [])
    except requests.exceptions.Timeout:
        logger.error('‚è±Ô∏è Request timeout')
        return None
    except Exception as e:
        logger.error(f'‚ùå Error fetching Vinted: {e}')
        return None

def item_exists(item_id: int) -> bool:
    try:
        conn = sqlite3.connect(CONFIG['DB_NAME'])
        cursor = conn.cursor()
        cursor.execute('SELECT 1 FROM items WHERE item_id = ?', (item_id,))
        result = cursor.fetchone() is not None
        conn.close()
        return result
    except Exception as e:
        logger.error(f'DB Error: {e}')
        return False

def save_item(item: Dict, status: str, team: Optional[str] = None, reason: Optional[str] = None):
    try:
        conn = sqlite3.connect(CONFIG['DB_NAME'])
        cursor = conn.cursor()
        cursor.execute(\"\"\"
            INSERT INTO items (
                item_id, title, price, team, brand, size, condition,
                image_url, vinted_url, status, reason_rejected, published_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        \"\"\", (
            item.get('id'),
            item.get('title'),
            item.get('price'),
            team,
            check_brand(item.get('title', '')),
            item.get('size_title'),
            item.get('status'),
            item.get('photo', {}).get('full_size_url'),
            f\"https://www.vinted.it/items/{item.get('id')}\",
            status,
            reason,
            datetime.fromtimestamp(item.get('created_at_ts', 0))
        ))
        conn.commit()
        conn.close()
    except Exception as e:
        logger.error(f'DB save error: {e}')

def mark_notified(item_id: int, notification_type: str):
    try:
        conn = sqlite3.connect(CONFIG['DB_NAME'])
        cursor = conn.cursor()
        cursor.execute(
            'INSERT INTO notified (item_id, notification_type) VALUES (?, ?)',
            (item_id, notification_type)
        )
        conn.commit()
        conn.close()
    except Exception as e:
        logger.error(f'DB notify error: {e}')

def send_discord_notification(item: Dict, team: str):
    if not CONFIG['DISCORD_WEBHOOK_URL']:
        return
    try:
        embed = {
            'title': item.get('title', 'N/A')[:256],
            'description': f\"**Team:** {team.upper()}\\n**Price:** ‚Ç¨{item.get('price', 'N/A')}\\n**Size:** {item.get('size_title', 'N/A')}\",
            'color': 0x00FF00,
            'thumbnail': {
                'url': item.get('photo', {}).get('full_size_url', '')
            },
            'fields': [
                {'name': 'Brand', 'value': check_brand(item.get('title', '')) or 'N/A', 'inline': True},
                {'name': 'Condition', 'value': item.get('status', 'N/A'), 'inline': True},
                {'name': 'Item ID', 'value': str(item.get('id', 'N/A')), 'inline': True},
                {'name': 'Published', 'value': datetime.fromtimestamp(item.get('created_at_ts', 0)).strftime('%H:%M:%S'), 'inline': True},
            ],
            'url': f\"https://www.vinted.it/items/{item.get('id')}\",
            'timestamp': datetime.now().isoformat()
        }
        data = {'embeds': [embed]}
        response = requests.post(CONFIG['DISCORD_WEBHOOK_URL'], json=data, timeout=5)
        if response.status_code == 204:
            logger.info('‚úÖ Discord notification sent')
            mark_notified(item.get('id'), 'discord')
        else:
            logger.warning(f\"Discord error: {response.status_code}\")
    except Exception as e:
        logger.error(f'Discord notification error: {e}')

def send_telegram_notification(item: Dict, team: str):
    if not CONFIG['TELEGRAM_BOT_TOKEN'] or not CONFIG['TELEGRAM_CHAT_ID']:
        return
    try:
        text = (
            f\"üéØ *TRACKSUIT FOUND*\\n\\n\"
            f\"*{item.get('title', 'N/A')}*\\n\"
            f\"üë• Team: {team.upper()}\\n\"
            f\"üí∞ Price: ‚Ç¨{item.get('price', 'N/A')}\\n\"
            f\"üëï Size: {item.get('size_title', 'N/A')}\\n\"
            f\"üì¶ Condition: {item.get('status', 'N/A')}\\n\"
            f\"üè∑Ô∏è ID: {item.get('id', 'N/A')}\\n\"
            f\"‚è∞ Published: {datetime.fromtimestamp(item.get('created_at_ts', 0)).strftime('%H:%M:%S')}\\n\"
            f\"üîó [View on Vinted](https://www.vinted.it/items/{item.get('id')})\"
        )
        url = f\"https://api.telegram.org/bot{CONFIG['TELEGRAM_BOT_TOKEN']}/sendMessage\"
        data = {
            'chat_id': CONFIG['TELEGRAM_CHAT_ID'],
            'text': text,
            'parse_mode': 'Markdown',
            'disable_web_page_preview': False
        }
        response = requests.post(url, json=data, timeout=5)
        if response.status_code == 200:
            logger.info('‚úÖ Telegram notification sent')
            mark_notified(item.get('id'), 'telegram')
        else:
            logger.warning(f\"Telegram error: {response.status_code}\")
    except Exception as e:
        logger.error(f'Telegram notification error: {e}')

def monitor_vinted():
    logger.info('üöÄ Starting Vinted Football Tracksuit Bot...')
    init_database()
    
    session = create_session()
    search_params = {
        'search_text': 'tuta calcio',
        'order': 'newest_first',
        'per_page': 30,
        'page': 1,
        'currency': 'EUR'
    }
    
    logger.info(f\"üìç Running check - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")
    
    found_count = 0
    approved_count = 0
    
    for vinted_url in CONFIG['VINTED_URLS']:
        items = fetch_vinted_items(session, vinted_url, search_params)
        
        if not items:
            continue
        
        for item in items:
            item_id = item.get('id')
            found_count += 1
            
            if item_exists(item_id):
                logger.debug(f\"‚è≠Ô∏è  Item {item_id} already processed\")
                continue
            
            is_valid, team, reason = validate_item(item)
            
            if is_valid:
                approved_count += 1
                save_item(item, 'approved', team)
                send_discord_notification(item, team)
                send_telegram_notification(item, team)
            else:
                save_item(item, 'rejected', reason=reason)
    
    logger.info(f\"üìä Check Summary: {found_count} items scanned, {approved_count} approved\")

monitor_vinted()
          "
      
      - name: Upload database as artifact
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: vinted_bot_database
          path: |
            vinted_bot.db
            vinted_bot.log
          retention-days: 7
